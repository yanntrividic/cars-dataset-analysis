---
title: "Cars dataset analysis"
output: pdf_document
author:
    - Aissatou Signate
    - Jacky Thay
    - Yann Trividic
abstract: |
  This is the abstract.

  It consists of two paragraphs
tags: [data analysis, cars, dataset, R, notebook, pca, clustering, statistics]
---

# Sujet

## Sujet du projet

Ce projet est un travail sur données réelles. Il s'agit de mettre en oeuvre une ou plusieurs méthodes vues en cours sur un jeu de données proposé pour chaque groupe.

Le projet doit suivre les étapes suivantes :

-   analyser le jeu de données proposé afin de choisir l'approche la plus adaptée à votre problème,
-   effectuer un prétraitement de votre base de données (si nécessaire),
-   justifier le choix de votre approche,
-   tester l'approche choisie sur l'ensemble de données en utilisant les options vues en cours,
-   analyser et commenter les résultats obtenus.

## Présentation du rapport

Le rapport du projet doit présenter de façon claire et concise:

-   l'objet de l'analyse,
-   la description des données (individus/variables utilisées, variables supplémentaires etc.),
-   l'analyse proprement dite,
-   les commentaires sur les résultats obtenus.

Ce rapport ne devrait pas dépasser 10 pages (les codes sources des programmes utilisés peuvent être mis en annexe).

Le projet sera jugé selon les critères suivants:

-   adéquation des méthodes utilisées aux données et problème étudiés,
-   richesse des analyses proposées (au delà du minimum requis),
-   justesse des commentaires sur les résultats,
-   qualité de la présentation du rapport.

## Remise du projet

Vous devez déposer votre rapport en format .pdf portant le nom : nom1_nom2_nom3_trinomeX.pdf au plus tard le 20 mai 2021 sous Moodle dans le dossier Rendu_projet_TND.

# Notes sur les différentes étapes

**1. analyser le jeu de données proposé afin de choisir l'approche la plus adaptée à votre problème**

-   Pour la **description des données**, tout ce qu'on a besoin de savoir est là : <https://www.kaggle.com/yugagrawal95/k-means-clustering-using-seaborn-visualization>. Décrire les différentes colonnes du jeu de données, les valeurs pouvant être prises par celles-ci, leur mode (numérique [entier, double, continue, discret], caractère, logique, `NULL`...), etc. Le nombre de colonnes aussi et la syntaxe comptent aussi. Quelles sont les données ordinales/qualitatives et quelles sont les données quantitatives.
-   Il faut **poser une problématique**, aussi générale soit-elle. Par exemple, quelle est l'influence des diverses variables sur les performances d'une voiture ? Comprendre quelles sont les avantages et les inconvénients d'avoir plus de chevaux, une plus grosse consommation d'essence, etc.
-   Combien a-t-on d'individus, combien de variables ?

**2. effectuer un prétraitement de votre base de données (si nécessaire)**

-   Effectuer une **analyse descriptive de base** (regarder ce qu'il est possible de déduire de la fonction `summary`, en faire un résumé, regarder ce qui ressort de la fonction `pairs`, et la fonction `quantile`, peut-être la matrice de corrélations ?)
-   Il y a-t-il des données ordinales ? [Non.] Textuelles ? [Oui, mais non, c'est pas des textes] Qualitatives ? [Oui.] Nominales ? [Oui.] Comment est-ce qu'on pourrait les traiter le mieux possible ? Les utiliser comme marqueurs dans la PCA et la CAH ? Par défaut, on mettra les variables qualitatives en tant que variables supplémentaires (ni l'ACP ni la CAH ne peuvent les traiter). Certaines variables quantitatives peuvent être considérées comme supplémentaires (par exemple, les variables qui décrivent d'autres variables ; le pH et le taux d'acide citrique)
-   Lister les variables qui sont le plus corrélées. On devrait retrouver ces corrélations dans les résultats de l'ACP
-   Potentiellement centrer les valeurs si les résultats de l'analyse univariée donne des résultats très hétérogènes. Càd si les valeurs prises par les variables sont sur des intervalles/variances/moyennes très différents.
-   Est-ce que tous les objets sont complets ? Il y a-t-il des **valeurs manquantes** (fonction `is.na`) ? Il y a-t-il des **valeurs aberrantes** à enlever (justifier pourquoi on les enlève) ? Décide-t-on de tolérer une marge d'erreur, remplacer les valeurs, supprimer les individus ? Essayer de comprendre pourquoi ces valeurs sont là, proposer des hypothèses si pertinent. Avec k-means par exemple, les valeurs aberrantes peuvent donner des résultats erronés. La forme des clusters est aussi importante.

**3. justifier le choix de votre approche**

-   Choisir un ensemble d'algorithmes à utiliser parmi ceux qu'on a vu (k-means, PCA, CAH, HCPC) et expliquer en quoi il serait pertinent de les utiliser au vu de ce qu'on a déduit du point précédent. Pour déterminer quel algo choisir, se référer aux caractéristiques des méthodes de classification (voir cours).

    -   Pourquoi l'ACP ? Trouver des individus similaires ; comment est-ce qu'une caractéristique va affecter les valeurs des autres caractéristiques, etc.

-   Avec chacun des algorithmes utilisés, justifier le choix la valeur de chacun des paramètres (exemple : pourquoi utiliser la méthode de Ward (voir cours), quels sont les résultats avec les autres méthodes ? Quel critère de qualité ?)

-   Ajouter l'utilisation d'autres d'outils statistiques : regression, chi², degré d'asymétrie (skewness), degré d'aplatissement (Kurtosis)...

**4. tester l'approche choisie sur l'ensemble de données en utilisant les options vues en cours**

-   Idéalement, je pense qu'il serait bien d'**enregistrer un fichier** `results.csv`, contenant les données de bases et une colonne pour chaque résultat pertinent.
-   Dans certains cas, il pourrait être intéressant de **diviser le jeu de données en différents sous-jeux** (par exemple, les voitures d'une certaine décennie, ou les voitures avec un certain type de moteur) et regarder comment les résultats varient au sein de ces sous-jeux. Pour ça, utiliser la fonction `aggregate`.
-   Consolider les résultats (consolider les résultats de la PCA avec HCPC).

**5. analyser et commenter les résultats obtenus**

-   Se baser sur les corrections fournies pour les TD 5 et 6.

**2. Objet de l'analyse**

-   Expliciter des tendances sous-jacentes du jeu de données, analyse descriptive du jeu de données pour mieux comprendre les liens entre les différentes variables, et ainsi mieux comprendre les performances des véhicules en fonction de leurs attributs.

# Code

## Lecture des données

Les données sont contenues dans un fichier `TXT`, les colonnes sont séparées par le caractère `,` et les lignes par un retour à la ligne. Les valeurs décimales sont séparées des valeurs entières par le caractère `.`.

```{r read_file}
cars = read.table(file, sep=",", header=T)
```

## Descriptions du jeu de données

```{r dataset_dimensions}
dim(cars)
```

Le jeu de données cars contient 261 individus définis par 8 variables. Chaque individu représente une liste de caractéristiques d'une voiture. En se basant sur [ce lien](https://www.kaggle.com/abineshkumark/carsdata), on obtient les descriptions suivantes :

1.  `mpg` [numérique, réel, continu] : la quantité prédite de gallons par mile (continue, arrondie à l'unité)
2.  `cylinders` [numérique, entier, discret] : le nombre de cylindres dans le moteur. Peut être 4, 6 ou 8.
3.  `cubicinches` [numérique, entier, continu] : mesure du volume du moteur de la voiture en pouces cube.
4.  `hp` [numérique, entier, continu] : puissance réelle du moteur en chevaux.
5.  `weightlbs` [numérique, entier, continu] : le poids de la voiture en livres.
6.  `time.to.60` [numérique, entier, continu] : durée nécessaire pour aller de 0 à 60 milles par heure.
7.  `year` [numérique, entier, discret] : année de fabrication de la voiture.
8.  `brand` [textuel, qualitatif, nominal] : région géographique de la marque de la voiture.

## Prétraitement

```{r na_values}
cars[rowSums(is.na(cars)) > 0,] # counts the number of rows with NA values 
```

Le jeu de données ne contient aucune valeur manquante, il peut donc être utilisé tel quel pour la suite de l'analyse.

Pour l'instant, seule la variable `brand` peut être considérée comme une variable supplémentaire car celle-ci est une variable textuelle et nominale. Au premier abord, toutes les autres variables doivent être utilisés dans l'analyse, celles-ci ne semblant pas être liées entre elles directement.

## Analyse univariée

```{r summary}
summary(cars[-8]) # the last column is not included as it is a textual variable
```

```{r quantiles}
apply(cars[1:7], MARGIN=2, FUN=quantile, probs=seq(0, 1, 0.1))
```

```{r correlations}
cars.correlations <- cor(cars[-8]) # the last column is not included as it is a textual variable
#write.csv(cars.correlations, file="../data/correlations.csv")

library(corrplot)
corrplot(cars.correlations)

#' Fonction permettant d'ordonner les différentes corrélations par ordre
#' décroissant par défaut en fonction de la valeur absolue de la corrélation
#'
#' @param df le dataframe dont les corrélations sont à extraire
#' @param order paramètre optionnel pour préciser l'ordre de tri (defaut:décroi)
#' @param threshold paramètre optionnel pour préciser un seuil (défaut: <=0.5)
#' @return un tableau contenant les corrélations ordonnées
getOrderedCorrelations <- function(df, order=T, threshold=0.5) {
    orderedCor <- as.data.frame(as.table(df))
    orderedCor <- orderedCor[order(abs(orderedCor$Freq), decreasing=order),]
    orderedCor <- orderedCor[orderedCor$Freq<1 & orderedCor$Freq>=threshold,]
    return(orderedCor)
}

# TODO: enlever les corrélations en double
getOrderedCorrelations(cars.correlations)
```

```{r boxplots}
for (i in 1:length(cars[-8])) {
    boxplot(cars[,i], main=names(cars[i]), type="l")
}
```

## Classification ascendante hiérarchique

```{r cah, out.width = "500px", fig.align='center', echo=FALSE}
library(cluster)
cah <- agnes(cars[, c(1:7)], diss=F, metric="euclidean", stand=T, method="ward")
plot(cah)
```

*Sur le graphique des résultats changez les titres des axes x et y par `Individus` et `Seuil` et le titre du graphique par `Dendogramme`. Changez par la suite la couleur des titres par du rouge.*

```{r q1-5, out.width = "500px", fig.align='center', echo=FALSE}
plot(cah, 
     xlab="Individus", ylab="Seuil", main="Dendogramme", 
     col.axis="red", col.main="red")
```

## Analyse en composantes principales

*Analysez la fonction `catdes()`. Utilisez cette fonction par rapport à la 14e variable du jeu de données `decathlon`.*

```{r q1-8-2}
library(FactoMineR)
# paramètres à ajuster
catdes(decathlon1[, c(1:7)], 7)
```

## Classification hiérarchique sur composantes principales

```{r}

```
