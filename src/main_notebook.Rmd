---
title: "Cars dataset analysis"
author:
- Aissatou Signate
- Jacky Thay
- Yann Trividic
output:
  html_document:
    df_print: paged
  pdf_document: default
abstract: |
  This is the abstract.
  It consists of two paragraphs
tags:
- data analysis
- cars
- dataset
- R
- notebook
- pca
- clustering
- statistics
editor_options: 
  markdown: 
    wrap: sentence
---

# Sujet

## Sujet du projet

Ce projet est un travail sur données réelles.
Il s'agit de mettre en oeuvre une ou plusieurs méthodes vues en cours sur un jeu de données proposé pour chaque groupe.

Le projet doit suivre les étapes suivantes :

-   analyser le jeu de données proposé afin de choisir l'approche la plus adaptée à votre problème,
-   effectuer un prétraitement de votre base de données (si nécessaire),
-   justifier le choix de votre approche,
-   tester l'approche choisie sur l'ensemble de données en utilisant les options vues en cours,
-   analyser et commenter les résultats obtenus.

## Présentation du rapport

Le rapport du projet doit présenter de façon claire et concise:

-   l'objet de l'analyse,
-   la description des données (individus/variables utilisées, variables supplémentaires etc.),
-   l'analyse proprement dite,
-   les commentaires sur les résultats obtenus.

Ce rapport ne devrait pas dépasser 10 pages (les codes sources des programmes utilisés peuvent être mis en annexe).

Le projet sera jugé selon les critères suivants:

-   adéquation des méthodes utilisées aux données et problème étudiés,
-   richesse des analyses proposées (au delà du minimum requis),
-   justesse des commentaires sur les résultats,
-   qualité de la présentation du rapport.

## Remise du projet

Vous devez déposer votre rapport en format .pdf portant le nom : nom1_nom2_nom3_trinomeX.pdf au plus tard le 20 mai 2021 sous Moodle dans le dossier Rendu_projet_TND.

# Notes sur les différentes étapes

<p style="text-align:justify;">

**1. analyser le jeu de données proposé afin de choisir l'approche la plus adaptée à votre problème**

-   Pour la **description des données**, tout ce qu'on a besoin de savoir est là : <https://www.kaggle.com/yugagrawal95/k-means-clustering-using-seaborn-visualization>. Décrire les différentes colonnes du jeu de données, les valeurs pouvant être prises par celles-ci, leur mode (numérique [entier, double, continue, discret], caractère, logique, `NULL`...), etc. Le nombre de colonnes aussi et la syntaxe comptent aussi. Quelles sont les données ordinales/qualitatives et quelles sont les données quantitatives.
-   Il faut **poser une problématique**, aussi générale soit-elle. Par exemple, quelle est l'influence des diverses variables sur les performances d'une voiture ? Comprendre quelles sont les avantages et les inconvénients d'avoir plus de chevaux, une plus grosse consommation d'essence, etc.
-   Combien a-t-on d'individus, combien de variables ?

**2. effectuer un prétraitement de votre base de données (si nécessaire)**

-   Effectuer une **analyse descriptive de base** (regarder ce qu'il est possible de déduire de la fonction `summary`, en faire un résumé, regarder ce qui ressort de la fonction `pairs`, et la fonction `quantile`, peut-être la matrice de corrélations ?)
-   Il y a-t-il des données ordinales ? [Non.] Textuelles ? [Oui, mais non, c'est pas des textes] Qualitatives ? [Oui.] Nominales ? [Oui.] Comment est-ce qu'on pourrait les traiter le mieux possible ? Les utiliser comme marqueurs dans la PCA et la CAH ? Par défaut, on mettra les variables qualitatives en tant que variables supplémentaires (ni l'ACP ni la CAH ne peuvent les traiter). Certaines variables quantitatives peuvent être considérées comme supplémentaires (par exemple, les variables qui décrivent d'autres variables ; le pH et le taux d'acide citrique)
-   Lister les variables qui sont le plus corrélées. On devrait retrouver ces corrélations dans les résultats de l'ACP
-   Potentiellement centrer les valeurs si les résultats de l'analyse univariée donne des résultats très hétérogènes. Càd si les valeurs prises par les variables sont sur des intervalles/variances/moyennes très différents.
-   Est-ce que tous les objets sont complets ? Il y a-t-il des **valeurs manquantes** (fonction `is.na`) ? Il y a-t-il des **valeurs aberrantes** à enlever (justifier pourquoi on les enlève) ? Décide-t-on de tolérer une marge d'erreur, remplacer les valeurs, supprimer les individus ? Essayer de comprendre pourquoi ces valeurs sont là, proposer des hypothèses si pertinent. Avec k-means par exemple, les valeurs aberrantes peuvent donner des résultats erronés. La forme des clusters est aussi importante.

**3. justifier le choix de votre approche**

-   Choisir un ensemble d'algorithmes à utiliser parmi ceux qu'on a vu (k-means, PCA, CAH, HCPC) et expliquer en quoi il serait pertinent de les utiliser au vu de ce qu'on a déduit du point précédent.
    Pour déterminer quel algo choisir, se référer aux caractéristiques des méthodes de classification (voir cours).

    -   Pourquoi l'ACP ? Trouver des individus similaires ; comment est-ce qu'une caractéristique va affecter les valeurs des autres caractéristiques, etc.

-   Avec chacun des algorithmes utilisés, justifier le choix la valeur de chacun des paramètres (exemple : pourquoi utiliser la méthode de Ward (voir cours), quels sont les résultats avec les autres méthodes ?
    Quel critère de qualité ?)

-   Ajouter l'utilisation d'autres d'outils statistiques : regression, chi², degré d'asymétrie (skewness), degré d'aplatissement (Kurtosis)...

**4. tester l'approche choisie sur l'ensemble de données en utilisant les options vues en cours**

-   Idéalement, je pense qu'il serait bien d'**enregistrer un fichier** `results.csv`, contenant les données de bases et une colonne pour chaque résultat pertinent.
-   Dans certains cas, il pourrait être intéressant de **diviser le jeu de données en différents sous-jeux** (par exemple, les voitures d'une certaine décennie, ou les voitures avec un certain type de moteur) et regarder comment les résultats varient au sein de ces sous-jeux. Pour ça, utiliser la fonction `aggregate`.
-   Consolider les résultats (consolider les résultats de la PCA avec HCPC).

**5. analyser et commenter les résultats obtenus**

-   Se baser sur les corrections fournies pour les TD 5 et 6.

**2. Objet de l'analyse**

-   Expliciter des tendances sous-jacentes du jeu de données, analyse descriptive du jeu de données pour mieux comprendre les liens entre les différentes variables, et ainsi mieux comprendre les performances des véhicules en fonction de leurs attributs.

# Code

## Lecture des données

Les données sont contenues dans un fichier `TXT`, les colonnes sont séparées par le caractère `,` et les lignes par un retour à la ligne.
Les valeurs décimales sont séparées des valeurs entières par le caractère `.`.

```{r read_file}
cars = read.table("../data/275-cars.txt", sep=",", header=T)
head(cars)
```

## Descriptions du jeu de données

```{r dataset_dimensions}
dim(cars)
```

Le jeu de données cars contient 261 individus définis par 8 variables.
Chaque individu représente une liste de caractéristiques d'une voiture.
En se basant sur [ce lien](https://www.kaggle.com/abineshkumark/carsdata), on obtient les descriptions suivantes :

<br>1.
`mpg` [numérique, réel, continu] : la quantité prédite de gallons par mile (continue, arrondie à l'unité) <br>2.
`cylinders` [numérique, entier, discret] : le nombre de cylindres dans le moteur.
Peut être 4, 6 ou 8.
<br>3.
`cubicinches` [numérique, entier, continu] : mesure du volume du moteur de la voiture en pouces cube.
<br>4.
`hp` [numérique, entier, continu] : puissance réelle du moteur en chevaux.
<br>5.
`weightlbs` [numérique, entier, continu] : le poids de la voiture en livres.
<br>6.
`time.to.60` [numérique, entier, continu] : durée nécessaire pour aller de 0 à 60 milles par heure.
<br>7.
`year` [numérique, entier, discret] : année de fabrication de la voiture.
<br>08.
`brand` [textuel, qualitatif, nominal] : région géographique de la marque de la voiture.

## Prétraitement

```{r na_values}
cars[rowSums(is.na(cars)) > 0,] # counts the number of rows with NA values 
```

```{r}
#le = LabelEncoder().fit(cars['brand'])
```

Le jeu de données ne contient aucune valeur manquante, il peut donc être utilisé tel quel pour la suite de l'analyse.

Pour l'instant, seule la variable `brand` peut être considérée comme une variable supplémentaire car celle-ci est une variable textuelle et nominale.
Au premier abord, toutes les autres variables doivent être utilisés dans l'analyse, celles-ci ne semblant pas être liées entre elles directement.

## Analyse univariée

<br>Nous allons dès à présent porcéder à une analyse univariée de notre base de données

<p style="text-align:justify;">

Grâce à la fonction summary, nous avons un aperçu global des différentes variables composant notre base de données en calculant des statistiques de base.
Pour les variables quantitatives il y a : Minimum, maximum, moyenne, médiane, 1er quartile, 3ème quartile.

```{r summary}
summary(cars[-8]) # the last column is not included as it is a textual variable
```

<p style="text-align:justify;">

Pour calculer des quantiles d'un jeu d'observations stocké dans un vecteur v, nous utilisons la fonction quantile.
Sans plus d'argument, celle-ci calcule les quantiles à 0%, 25%, 50%, 75%,100%.
Pour avoir les quantiles à d'autres ordres, il faut manipuler le paramètre probs.Dans notre cas , nous les calculons par intervalle de 10% :

```{r quantiles}
apply(cars[1:7], MARGIN=2, FUN=quantile, probs=seq(0, 1, 0.1))
```

<p style="text-align:justify;">

<br>Une matrice de corrélation est utilisée pour évaluer la dépendence entre plusieurs variables de façon simultanée.
Le résultat est une table contenant les coefficients de corrélation entre chaque variable et les autres.

Pour la calculer , R propose la fonction cor().
Le résultat de cette fonction est une table de coefficients de corrélation entre chaque variable et les autres.

```{r matrice  correlations}
cars.correlations <- cor(cars[-8]) # the last column is not included as it is a textual variable
#write.csv(cars.correlations, file="../data/correlations.csv")
cars.correlations
```

<p style="text-align:justify;">

Nous pouvons également visualiser et représenter graphiquement notre matrice avec un corrélogramme.
Cet outil permet de mettre en évidence les variables les plus corrélées : les coefficients de corrélation sont colorés en fonction de leur valeur.
Ici ils ont été ordonné fonction du degré de corrélation.
Nous voyons bien, grâce au coefficient de corrélation affiché pour chaque variable en fonction des autres,lesquelles sont les plus dépendantes

<p style="text-align:justify;">

<br>La valeur 1 signifie que les deux variables sont exactement corrélées, c'est le cas d'une relation exactement linéaire entre deux variables.
<br>Le 0.95 entre cylindre et cubinches signifie que le nombre de cylindres du véhicule(cubinches) joue pour 90,25% (0,95)\*(0,95)sur la valeur du volume moteur

```{r corrplot}
library(corrplot)
corrplot(cars.correlations,addCoef.col = "grey", number.cex = 0.5)

#' Fonction permettant d'ordonner les différentes corrélations par ordre
#' décroissant par défaut en fonction de la valeur absolue de la corrélation
#'
#' @param df le dataframe dont les corrélations sont à extraire
#' @param order paramètre optionnel pour préciser l'ordre de tri (defaut:décroi)
#' @param threshold paramètre optionnel pour préciser un seuil (défaut: <=0.5)
#' @return un tableau contenant les corrélations ordonnées
getOrderedCorrelations <- function(df, order=T, threshold=0.5) {
    orderedCor <- as.data.frame(as.table(df))
    orderedCor <- orderedCor[order(abs(orderedCor$Freq), decreasing=order),]
    orderedCor <- orderedCor[orderedCor$Freq<1 & orderedCor$Freq>=threshold,]
    return(orderedCor)
}

# TODO: enlever les corrélations en double
getOrderedCorrelations(cars.correlations)
```

<p style="text-align:justify;">

Un box-plot est un graphique composé d'un rectangle, deux droites sortent afin de représenter certains éléments des données.

<p style="text-align:justify;">

La valeur centrale du graphique est la médiane (il existe autant de valeur supérieures qu'inférieures à cette valeur dans l'échantillon).

<p style="text-align:justify;">

Les bords du rectangle sont les quartiles (Pour le bord inférieur, un quart des observations ont des valeurs plus petites et trois quart ont des valeurs plus grandes, le bord supérieur suit le même raisonnement).

<p style="text-align:justify;">

Les extrémités des moustaches sont calculées en utilisant 1.5 fois l'espace interquartile (la distance entre le 1er et le 3ème quartile).
On peut remarquer que 50% des observations se trouvent à l'intérieur de la boîte.Pour

Par exemple , pour la variable mpg (Miles par galon), on s'aperçoit que sa valeur médiane est 22 , et que les valeurs sont un peu plus dispersés au dessus de cette valeur médiane.
Pour la variable cylindre , on voit une symétrie parfaite : il y a autant de valeur dispersés en dessous et au dessus de la médiane qui vaut 6 pour cete valeur.
De même pour la variable year.
En ce qui concerne la variable "time to 60" , on aperçoit des points sur le graphique : ce sont des valeurs aberrantes.
Une valeur aberrante est une valeur qui s'écarte fortement des valeurs des autres observations, anormalement faible ou élevée.
Ici ces valeurs correspondent en partie aux valeurs minimum et maximum de la variable, à savoir 8 et 25.

```{r boxplots}
for (i in 1:length(cars[-8])) {
    boxplot(cars[,i], main=names(cars[i]), type="l")
}
```

## Classification ascendante hiérarchique

```{r cah, out.width = "500px", fig.align='center', echo=FALSE}
library(cluster)
cah <- agnes(cars[, c(1:7)], diss=F, metric="euclidean", stand=T, method="ward")
plot(cah)
```

*Sur le graphique des résultats changez les titres des axes x et y par `Individus` et `Seuil` et le titre du graphique par `Dendogramme`. Changez par la suite la couleur des titres par du rouge.*

```{r q1-5, out.width = "500px", fig.align='center', echo=FALSE}
plot(cah, 
     xlab="Individus", ylab="Seuil", main="Dendogramme", 
     col.axis="red", col.main="red")
```

## Analyse en composantes principales

*Analysez la fonction `catdes()`. Utilisez cette fonction par rapport à la 14e variable du jeu de données `decathlon`.*

```{r q1-8-2}
library(FactoMineR)
# paramètres à ajuster
catdes(cars[, c(1:8)], 8)
```

## Classification hiérarchique sur composantes principales

```{r}

```
